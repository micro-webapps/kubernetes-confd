#!/usr/bin/env python
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Jan Kaluza <jkaluza at redhat dot com>
# Description: Watch for new web-apps using the Kubernetes API, regenerates
# the config files and reloads the webserver.

from __future__ import print_function
from urlparse import urlparse
import sys
import json
import os
import httplib
import time
import uuid

old_services = []

def needs_regeneration(cfg):
    global old_services
    services = []
    for item in cfg["items"]:
        if not item.has_key("annotations") or not item["annotations"].has_key("webconf-spec"):
            continue
        services.append(item)

    if old_services == services:
        return False
    old_services = services
    return True

def generate_config(kube_host, kube_port, key_file, cert_file, kube_namespace, token):
    config_dir = sys.argv[1]
    webconf_cmd = sys.argv[2]
    restart_cmd = sys.argv[3]

    if sys.version_info >= (2,7,9):
        import ssl
        conn = httplib.HTTPSConnection(kube_host, kube_port, key_file, cert_file, context=ssl._create_unverified_context())
    else:
        conn = httplib.HTTPSConnection(kube_host, kube_port, key_file, cert_file)

    headers = {}
    if token:
        headers["Authorization"] = "Bearer " + token

    if kube_namespace:
        url = "/api/v1/services?namespace=" + kube_namespace
    else:
        url = "/api/v1/services/"

    conn.request("GET", url, headers = headers)
    response = conn.getresponse(buffering=True)
    if response.status != 200:
        print(response.status, response.read())
        return

    cfg = json.load(response)
    if not needs_regeneration(cfg):
        return

    os.system("rm -f {0}/*.json".format(config_dir))
    os.system("rm -f {0}/*.cfg".format(config_dir))
    os.system("rm -f {0}/*.conf".format(config_dir))

    envcmd = ""

    for item in cfg["items"]:
        if not item.has_key("annotations") or not item["annotations"].has_key("webconf-spec"):
            continue

        webconfig = item["annotations"]["webconf-spec"]
        item["webconfig"] = json.loads(webconfig)
        print(item)

        envcmd += "export "
        envcmd += item["id"].upper().replace("-", "_") + "_PORT="
        envcmd += "tcp://" + item["portalIP"] + ":" + str(item["port"])
        envcmd += "; "

        f = open(config_dir + "/" + item["uid"] + ".json", "w")
        json.dump(item, f)
        f.close()
        del item["webconfig"]

    envcmd += " " + webconf_cmd
    print (envcmd)
    os.system(envcmd)
    os.system(restart_cmd)

def getenv_as_file(name, default):
    data = os.getenv(name + "_DATA", default)
    if data == default:
        data = os.getenv(name + "_FILE", default)
        if data == "None":
            return None
    if data == "None":
        return None

    filename = "/" + str(uuid.uuid1())
    f = open(filename, "w")
    f.write(data.replace("\\n", "\n"))
    f.close()
    return filename

def main():
    if len(sys.argv) != 4:
        print("Usage:", sys.argv[0], "<output_config_dir> <webconf_implementation_cmd> <webserver_restart_cmd>")
        return 1

    kube_host = os.getenv("KUBERNETES_SERVICE_HOST", False)
    kube_port = os.getenv("KUBERNETES_SERVICE_PORT", False)
    kube_namespace = os.getenv("KUBERNETES_NAMESPACE", False)
    cert_file = getenv_as_file("KUBERNETES_CLIENT_CERTIFICATE", None)
    key_file = getenv_as_file("KUBERNETES_CLIENT_KEY", None)

    if kube_host == False or kube_port == False:
        print("KUBERNETES_SERVICE_HOST or KUBERNETES_SERVICE_PORT not set, exiting")
        return 1

    token = None
    if os.path.exists("/var/run/secrets/kubernetes.io/serviceaccount/token"):
        f = open("/var/run/secrets/kubernetes.io/serviceaccount/token")
        token = f.read()
        f.close()

    while True:
        time.sleep(2)
        generate_config(kube_host, kube_port, key_file, cert_file, kube_namespace, token)
        time.sleep(5)

    return 0

sys.exit(main())
